"""
Overview
--------

This module contains a routines to convert the output of

    sklearn.datasets.make_blobs
    sklearn.datasets.make_regression
    sklearn.datasets.make_classification

to the following containers

    xarray.Dataset
    numpy.array
    pandas.DataFrame

as well as allowing us to do some postprocessing of the data conveniently.

The sklearn functions all output a tuple (X, y) where

    X is a n_samples by n_features numpy.array of features
    y is a n_samples numpy.array of labels

While the simulations/sampling done by sklearn is useful, the final output
may fall short of users with more complex needs.

Why this is useful
------------------

The reasons to wrap the sklearn routines are:

- We want new types easily (xarray.Dataset, etc.)
- We want multidimensional features.
- We want to generate sample weights together with synthetic data.

Motivating usecases:

- Generate data to test models that predict temperature or humidity at
  3d-spatial coordinates and time based on earlier measurements at nearby/same
  coordinates.

Approach
--------

The idea here is to redefine in this module the sklearn functions mentioned
above. Each one of the new functions has the same signature as in sklearn, and
does the same computation, but returns a XyTransformer object that has various
methods to postprocess that (X, y) data. For example, you can do

>>> m = make_blobs()
>>> m.to_dataframe(feature_names=['feat1', 'feat2'], label_name='response')

to convert the data generated by sklearn to pandas data structures suitably
named.

"""


import sklearn.datasets
import inspect

import numpy as np
import xarray as xr
import pandas as pd

from collections import Sequence, OrderedDict
from functools import partial, wraps


class XyTransformer:
    "Transforms a pair (feature_matrix, labels_vector) with to_* methods."
    def __init__(self, X, y=None):
        """Initalizes an XyTransformer object.

        Access the underlying feature matrix X and labels y with self.X and
        self.y, respectively.
        """
        self.X = X  # always a 2d numpy.array
        self.y = y  # always a 1d numpy.array
    def to_array(self, feature_shape=None):
        "Return X, y NumPy arrays with given shape"
        if feature_shape:
            X, y = self.X.reshape(feature_shape), self.y
        else:
            X, y = self.X, self.y
        return X, y
    def to_dataframe(self, feature_names=None, label_name=None):
        "Return a dataframe X and a label series y with named variables."
        Xdf = pd.DataFrame(self.X, columns=feature_names)
        ys = pd.Series(self.y, name=label_name)
        return Xdf, ys
    def to_flat_xarray_with_layers(self, layers=None):
        """Return an Xarray with layers and space

        [TODO]: improve this docstring.

        [TODO]: should this be a static method that takes data as input?
        """
        assert self.X.ndim == 2
        ncols = self.X.shape[1]

        def synthetic_coords(shape, layers):
            space = np.arange(shape[0])
            coords = dict(layers=layers, space=space)
            dims = ('space', 'layers')
            return coords, dims

        if not layers:
            layers = ['label_{}'.format(c) for c in range(ncols)]
        coords, dims = synthetic_coords(self.X.shape, layers)
        xarr = xr.DataArray(self.X, coords=coords, dims=dims)
        return xarr


def _make_base(skl_sampler_func):
    """Maps a make_* function from sklearn to a XyTransformer

    The goal is to use the make_* functions from sklearn to generate the data,
    but then postprocess it with the various to_* methods from a XyTransformer
    class.

    Note: a decorator doesn't solve this. It could add the functionality, but
    it would not change the docstring or the signature of the function, as it
    would keep the original one from the wrapped function from sklearn. So we
    have to do the process manually.
    """
    def wrapper(*args, **kwargs):
        X, y = skl_sampler_func(*args, **kwargs)
        return XyTransformer(X, y)
    # We now have some tasks: (1) fix the docstring and (2) fix the signature of `wrapper`.
    # Task 1 of 2: fixing the docstring of `wrapper`
    preamble_doc = """Like {skl_funcname}, but returns an XyTransformer object.

    See Also
    --------
    {skl_funcname}
    {xy_transformer}

    """.format(
            skl_funcname=(skl_sampler_func.__module__ + '.' + skl_sampler_func.__name__),
            xy_transformer=(XyTransformer.__module__ + '.' + XyTransformer.__name__)
    )
    wrapper.__doc__ = preamble_doc # + skl_sampler_func.__doc__
    # Task 2 of 2: fixing the signature of `wrapper`
    argspec = inspect.getfullargspec(skl_sampler_func)
    params = [inspect.Parameter(name=pname, kind=inspect.Parameter.POSITIONAL_OR_KEYWORD, default=pdefault)
              for (pname, pdefault) in zip(argspec.args, argspec.defaults)]
    wrapper.__signature__ = inspect.Signature(params)
    wrapper.__name__ = skl_sampler_func.__name__
    return wrapper


make_blobs = _make_base(sklearn.datasets.make_blobs)
make_classification = _make_base(sklearn.datasets.make_classification)
make_regression = _make_base(sklearn.datasets.make_regression)

